ğŸ“Œ MAP (Java â€“ DSA Concept)
ğŸ”¹ What is Map?

Map is a data structure that stores data in keyâ€“value pairs.

Each key is unique, but values can be duplicate.

Syntax:
Map<Integer, Integer> mp = new HashMap<>();
// or
Map<Integer, Integer> mp = new LinkedHashMap<>();
// or
Map<Integer, Integer> mp = new TreeMap<>();

ğŸ”¹ Why do we use Map?

By using Map, we can:

ğŸ”¢ Count frequency of elements

ğŸ” Search keys efficiently

âŒ Avoid duplicate keys

ğŸ“Š Store data in keyâ€“value form

ğŸ”¢ Sort keys (using TreeMap)

ğŸ‘‰ This line is important for your mind map.

ğŸ“Œ Types of Map
1ï¸âƒ£ HashMap
ğŸ”¹ Properties:

Does NOT maintain any order

Uses hashing

Fastest Map implementation

ğŸ”¹ Time Complexity:

put() â†’ O(1) (average)

get() â†’ O(1)

containsKey() â†’ O(1)

ğŸ”¹ Important Points:

Allows one null key

Allows multiple null values

Order is random

2ï¸âƒ£ LinkedHashMap
ğŸ”¹ Properties:

Maintains insertion order

Internally uses:

Hash table + Doubly Linked List

ğŸ”¹ Time Complexity:

put(), get() â†’ O(1)

3ï¸âƒ£ TreeMap
ğŸ”¹ Properties:

Maintains sorted order of keys (ascending)

Internally implemented as:

Red-Black Tree

ğŸ”¹ Time Complexity:

put(), get() â†’ O(log n)

ğŸ”¹ Important Points:

Does NOT allow null keys

Used when sorted keys are required

ğŸ“Œ Counting Frequency of Elements (Code)
ğŸ”¹ Problem Description:

Given an array, count the frequency of each element.

ğŸ”¹ Approach:

Traverse the array

If element exists â†’ increase count

Else â†’ insert with count = 1

ğŸ”¹ Code (Using containsKey):
Map<Integer, Integer> map = new HashMap<>();
int[] arr = {1, 2, 2, 3, 1, 4};

for (int num : arr) {
    if (map.containsKey(num)) {
        map.put(num, map.get(num) + 1);
    } else {
        map.put(num, 1);
    }
}

System.out.println(map);

ğŸ”¹ Optimized Code (Using getOrDefault):
Map<Integer, Integer> map = new HashMap<>();
int[] arr = {1, 2, 2, 3, 1, 4};

for (int num : arr) {
    map.put(num, 1 + map.getOrDefault(num, 0));
}

System.out.println(map);

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

ğŸ“Œ Count of DISTINCT Elements (IMPORTANT ğŸ”¥)
âœ… Method 1: Using Set (BEST & SIMPLE)
ğŸ”¹ Code:
int[] arr = {1, 2, 2, 3, 1, 4};

Set<Integer> set = new HashSet<>();
for (int num : arr) {
    set.add(num);
}

System.out.println(set.size());

ğŸ”¹ Explanation:

Set stores only unique elements

Size of set = count of distinct elements

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

âœ… Method 2: Using Map
ğŸ”¹ Code:
Map<Integer, Integer> map = new HashMap<>();
int[] arr = {1, 2, 2, 3, 1, 4};

for (int num : arr) {
    map.put(num, 1 + map.getOrDefault(num, 0));
}

System.out.println(map.size());

ğŸ”¹ Explanation:

Keys are unique

Number of keys = distinct count

ğŸ“Œ Iterating Over Map
ğŸ”¹ Code:
for (int key : map.keySet()) {
    System.out.println(key + " : " + map.get(key));
}

ğŸ“Œ Important Notes (Very Exam-Useful)

Keys are always unique

Values can be duplicate

Only one null key allowed (HashMap)

remove(key) removes entire key-value pair

Searching a key is easy and fast

ğŸ“Œ Final Mind Map Summary (Last Branch)

Map stores keyâ€“value pairs

HashMap â†’ fast, unordered

LinkedHashMap â†’ insertion order

TreeMap â†’ sorted keys

Used for:

Frequency count

Distinct elements

Fast searching
