1.Merge two sorted linked lists using constant space
-----------------------------------------------------------------------------------------
Problem Statement
Merge two sorted singly linked lists into a single sorted linked list using constant extra space, and return the head of the merged list.

Approach / Idea
Since both linked lists are already sorted, we compare nodes one by one.
We reuse existing nodes (no new nodes created).
Only pointers are rearranged → constant space.

Algorithm (High-Level Steps)
If first list is empty, return head of second list.
If second list is empty, return head of first list.
Decide the head of the merged list by comparing the first nodes.
Use a pointer temp to build the merged list.
Traverse both lists:
Attach the smaller node to temp
Move the pointer of the selected list
Attach the remaining nodes (if any).
Return the head of the merged list.

Codeclass Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        // If one list is empty
        if (l1 == null) return l2;
        if (l2 == null) return l1;

        ListNode ptr = null;

        // Decide head of merged list
        if (l1.val <= l2.val) {
            ptr = l1;
            l1 = l1.next;
        } else {
            ptr = l2;
            l2 = l2.next;
        }

        ListNode temp = ptr;

        // Merge while both lists have nodes
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                temp.next = l1;
                l1 = l1.next;
            } else {
                temp.next = l2;
                l2 = l2.next;
            }
            temp = temp.next;
        }

        // Attach remaining nodes
        if (l1 != null)
            temp.next = l1;
        else
            temp.next = l2;

        return ptr;
    }
}

Code Summary (What is Happening)
First, we handle edge cases where one list is empty.
We compare the first nodes of both lists to decide the head of the merged list.
temp pointer is used to build the merged list step by step.
While both lists are not empty:
Compare values
Attach the smaller node
Move the corresponding pointer
After the loop, one list may still have elements:
Attach all remaining nodes directly
Finally, return the head pointer ptr.

Time Complexity
O(N + M)
Where:
N = number of nodes in first list
M = number of nodes in second list
Each node is visited only once.

Space Complexity
O(1)
No extra data structures used
Only pointer manipulation (constant space).

2. palindromic list
-----------------------------------------------------------------------------
Problem Statement
Given a singly linked list, check whether the list is a palindrome.
A linked list is palindromic if it reads the same forward and backward.

Approach / Idea
Find the middle node of the linked list using slow and fast pointers.
Split the list into two halves.
Reverse the second half of the list.
Compare the first half and the reversed second half node by node.
If all corresponding values match, the list is a palindrome.

Algorithm (High-Level Steps)
If the list is empty, return true.
Find the middle node of the linked list.
Split the list into two halves.
Reverse the second half of the list.
Compare nodes of the first half and reversed second half.
If any mismatch occurs, return false.
If all nodes match, return true.

Code

class BeingZero {

    public boolean isPalindromic(SLLNode A) {

        if (A == null)
            return true;

        SLLNode m = midNode(A);
        SLLNode h2 = m.next;
        m.next = null;

        h2 = reverse(h2);

        while (h2 != null) {
            if (A.data != h2.data)
                return false;

            A = A.next;
            h2 = h2.next;
        }
        return true;
    }

    public SLLNode midNode(SLLNode h) {
        SLLNode s = h, f = h;

        while (f != null && f.next != null && f.next.next != null) {
            s = s.next;
            f = f.next.next;
        }
        return s;
    }

    public SLLNode reverse(SLLNode h) {
        if (h == null)
            return null;

        SLLNode prev = null;
        SLLNode cur = h;
        SLLNode next = null;

        while (cur != null) {
            next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}

Code Summary (What is Happening)
midNode() uses slow and fast pointers to find the middle of the list.
The list is split into two halves by setting mid.next = null.
reverse() reverses the second half in-place.
The first half and reversed second half are compared node by node.
If any mismatch is found, the function returns false.
If all values match, the function returns true.

Time Complexity
O(N)
Each node is visited at most once (finding middle + reversing + comparison).

Space Complexity
O(1)
No extra data structures are used — only pointer manipulation.

3. Linked List Cycle Problems
a) Check if cycle is present
b) Find start node of the cycle
c) Find length of the cycle
d) Make the list acyclic
---------------------------------------------------------------------------
Problem Statement
Given a singly linked list,
Check whether a cycle exists
If a cycle exists, find the starting node of the cycle
Find the length of the cycle
Remove the cycle and make the list acyclic
All operations must be done using constant extra space.

Approach / Idea
Use Floyd’s Cycle Detection Algorithm (slow & fast pointers).
If slow and fast meet → cycle exists.
Reset slow to head to find start of cycle.
Traverse the cycle to count its length.
Break the cycle by setting the last node’s next to null.

Algorithm (High-Level Steps)
Initialize slow and fast at head.
Move slow by 1 step and fast by 2 steps.
If slow == fast, cycle is detected.
Reset slow to head.
Move both pointers one step at a time to find start of cycle.
Traverse cycle once to find cycle length.
Traverse again to find the last node of cycle.
Set last.next = null to remove cycle.

Code
class Solution {

    static class Result {
        boolean hasCycle;
        Node cycleStart;
        int cycleLength;
    }

    public static Result detectAndRemoveCycle(Node head) {

        Result res = new Result();
        if (head == null) return res;

        Node slow = head, fast = head;

        // Step 1: Detect cycle
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast)
                break;
        }

        // No cycle
        if (fast == null || fast.next == null) {
            res.hasCycle = false;
            return res;
        }

        res.hasCycle = true;

        // Step 2: Find start of cycle
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        res.cycleStart = slow;

        // Step 3: Find cycle length
        int count = 1;
        Node temp = slow.next;
        while (temp != slow) {
            count++;
            temp = temp.next;
        }
        res.cycleLength = count;

        // Step 4: Remove cycle
        Node prev = slow;
        while (prev.next != slow) {
            prev = prev.next;
        }
        prev.next = null;

        return res;
    }
}


Code Summary (What is Happening)
Slow and fast pointers detect whether a cycle exists.
If no cycle → return immediately.
After detection:
Reset slow to head.
Move slow and fast together to find cycle start.
Traverse the cycle to count number of nodes.
Find the last node of cycle and set its next = null.
The linked list becomes acyclic.

Time Complexity
O(N)
Each node is visited a constant number of times.

Space Complexity
O(1)
Only pointers are used; no extra data structures.




