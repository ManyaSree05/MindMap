ğŸ“Œ What is a Subarray?
ğŸ”¹ Definition:

A subarray is a contiguous (continuous) part of an array.

ğŸ‘‰ Contiguous means: elements must be next to each other in the original array.

ğŸ”¹ Example:
Array: [1, 2, 3]

âœ… Subarrays:

[1]

[2]

[3]

[1, 2]

[2, 3]

[1, 2, 3]

âŒ Not Subarrays:

[1, 3] âŒ (not continuous)

ğŸ“Œ How to Find All Subarrays?
ğŸ”¹ Basic Idea:

Fix a starting index

Extend the ending index

Every continuous range is a subarray

ğŸ”¹ Method 1: Using Two Loops (Brute Force)
ğŸ”¹ Logic:

First loop â†’ choose starting index i

Second loop â†’ choose ending index j

Elements from i to j form a subarray

ğŸ”¹ Code (Java):
int[] arr = {1, 2, 3};

for (int i = 0; i < arr.length; i++) {
    for (int j = i; j < arr.length; j++) {
        for (int k = i; k <= j; k++) {
            System.out.print(arr[k] + " ");
        }
        System.out.println();
    }
}

ğŸ”¹ Time Complexity:

O(nÂ³) (printing elements)

ğŸ“Œ Counting Number of Subarrays (Formula)

If array length = n

ğŸ”¹ Total subarrays:
ğ‘›
(
ğ‘›
+
1
)
2
2
n(n+1)
	â€‹

ğŸ”¹ Example:
n = 3
Total subarrays = 3 Ã— 4 / 2 = 6

ğŸ“Œ How to Find Subarrays with a Condition?

Examples:

Subarray sum = 0

Subarray sum = K

Subarray with maximum sum

ğŸ”¹ Brute Force Approach:

Generate all subarrays

Check condition for each

ğŸ”¹ Code Skeleton:
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += arr[j];

        if (sum == K) {
            // valid subarray
        }
    }
}

ğŸ”¹ Time Complexity:

O(nÂ²)

ğŸ“Œ Why Brute Force is NOT Good?

Too slow for large inputs

Leads to TLE (Time Limit Exceeded)

ğŸ‘‰ Thatâ€™s why we use:

ğŸ”¥ Prefix Sum + HashMap
ğŸ“Œ Mind Map Summary (Perfect Short Points)

Subarray = continuous part of array

Order matters

Total subarrays = n(n+1)/2

Brute force â†’ O(nÂ²) / O(nÂ³)

Optimized using Prefix Sum + Map


ğŸ“Œ Counting Subarrays using Map
ğŸ”¹ Problem 1: Count total subarrays whose sum = 0
ğŸ”¹ Problem 2: Count total subarrays whose sum = K

ğŸ‘‰ Both are solved using the same concept: Prefix Sum + HashMap

ğŸ”¹ Why do we use Map here?

To store prefix sums

To count how many times a prefix sum has appeared

This helps us find subarrays in O(n) instead of O(nÂ²)

ğŸ§  Core Concept: Prefix Sum
ğŸ”¹ What is Prefix Sum?

Prefix Sum at index i = sum of elements from index 0 to i

Example:

arr = [1, -1, 2, -2, 3]

Prefix Sum:
index:      0   1   2   3   4
prefixSum:  1   0   2   0   3

ğŸ“Œ CASE 1: Count Subarrays with Sum = 0
ğŸ”¹ Key Idea:

If the same prefix sum appears again,
ğŸ‘‰ the elements between them form a subarray with sum 0

ğŸ”¹ Algorithm (Logic):

Initialize sum = 0

Use a HashMap<sum, frequency>

Put (0, 1) initially â†’ very important

Traverse array:

Add current element to sum

If sum exists in map:

Add its frequency to answer

Update map with current sum

ğŸ”¹ Code (Java)
public class SubarraySumZero {
    public static int countSubarrays(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        int count = 0;

        map.put(0, 1); // important

        for (int num : arr) {
            sum += num;

            if (map.containsKey(sum)) {
                count += map.get(sum);
            }

            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }

        return count;
    }
}

ğŸ”¹ Dry Run Example:
arr = [1, -1, 2, -2]

prefix sums: 1, 0, 2, 0

sum = 0 appears twice â†’ subarrays with sum 0

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

ğŸ”¹ Summary:

Same prefix sum â†’ sum between them is 0

Map stores frequency of prefix sums

ğŸ“Œ CASE 2: Count Subarrays with Sum = K
ğŸ”¹ Key Idea:

If

currentPrefixSum - K exists in map


ğŸ‘‰ then a subarray with sum K exists

ğŸ”¹ Mathematical Explanation:
prefixSum[j] - prefixSum[i] = K
â‡’ prefixSum[i] = prefixSum[j] - K

ğŸ”¹ Algorithm:

Initialize sum = 0

Use HashMap<sum, frequency>

Put (0, 1) initially

Traverse array:

sum += current element

If (sum - K) exists in map:

add its frequency to count

Update map

ğŸ”¹ Code (Java)
public class SubarraySumK {
    public static int countSubarrays(int[] arr, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        int count = 0;

        map.put(0, 1); // important

        for (int num : arr) {
            sum += num;

            if (map.containsKey(sum - k)) {
                count += map.get(sum - k);
            }

            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }

        return count;
    }
}

ğŸ”¹ Example:
arr = [1, 2, 3]
k = 3

Subarrays:
[1,2]
[3]

Answer = 2

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

ğŸ“Œ Comparison (Mind Map Friendly)
Case	Condition Checked
Sum = 0	same prefix sum
Sum = K	prefixSum - K
ğŸ“Œ Final Mind Map Summary (1â€“2 lines)

Use Prefix Sum + HashMap

Map stores sum â†’ frequency

Reduces time from O(nÂ²) â†’ O(n)

Used for:

Subarray sum = 0

Subarray sum = K


ğŸ“Œ Finding LENGTH of Subarrays using Map + Prefix Sum

We usually solve 2 very important problems:

1ï¸âƒ£ Longest subarray with sum = 0
2ï¸âƒ£ Longest subarray with sum = K

ğŸ‘‰ Key difference from counting:

For length, we store the first index of a prefix sum

For count, we store frequency

ğŸ”¹ Core Concept (Prefix Sum Recap)

Prefix Sum at index i:

prefixSum[i] = arr[0] + arr[1] + ... + arr[i]

ğŸ“Œ CASE 1: Longest Subarray with Sum = 0
ğŸ”¹ Key Idea:

If the same prefix sum appears again,
ğŸ‘‰ the subarray between them has sum = 0

To get maximum length, we:

Store the first occurrence index of each prefix sum

ğŸ”¹ Algorithm:

Initialize sum = 0, maxLen = 0

Use HashMap<sum, index>

Put (0, -1) initially

Traverse array:

sum += arr[i]

If sum exists in map:

length = i - map.get(sum)

update maxLen

Else:

store sum with index i

ğŸ”¹ Code (Java)
public class LongestSubarraySumZero {
    public static int longestSubarray(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0, maxLen = 0;

        map.put(0, -1); // important

        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];

            if (map.containsKey(sum)) {
                maxLen = Math.max(maxLen, i - map.get(sum));
            } else {
                map.put(sum, i); // store first occurrence
            }
        }

        return maxLen;
    }
}

ğŸ”¹ Example Dry Run:
arr = [1, -1, 2, -2, 3]

prefix sums: 1, 0, 2, 0, 3

sum = 0 at index 3
length = 3 - (-1) = 4

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

ğŸ”¹ Summary:

Same prefix sum â†’ sum = 0

Store first index only

ğŸ“Œ CASE 2: Longest Subarray with Sum = K
ğŸ”¹ Key Idea:

If

prefixSum - K exists in map


ğŸ‘‰ subarray with sum K exists

To get maximum length, store first occurrence index

ğŸ”¹ Algorithm:

Initialize sum = 0, maxLen = 0

Use HashMap<sum, index>

Put (0, -1) initially

Traverse array:

sum += arr[i]

If (sum - K) exists:

length = i - map.get(sum - K)

update maxLen

If sum not in map:

store sum with index

ğŸ”¹ Code (Java)
public class LongestSubarraySumK {
    public static int longestSubarray(int[] arr, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0, maxLen = 0;

        map.put(0, -1); // important

        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];

            if (map.containsKey(sum - k)) {
                maxLen = Math.max(maxLen, i - map.get(sum - k));
            }

            if (!map.containsKey(sum)) {
                map.put(sum, i); // store first occurrence
            }
        }

        return maxLen;
    }
}

ğŸ”¹ Example:
arr = [1, 2, 3, 1, 1, 1, 1]
k = 3

Longest subarray: [1,1,1]
Length = 3

ğŸ”¹ Time Complexity:

O(n)

ğŸ”¹ Space Complexity:

O(n)

ğŸ“Œ Important Difference (VERY EXAM-IMPORTANT)
Problem Type	Map Stores
Count subarrays	frequency
Longest length	first index
ğŸ“Œ Final Mind Map Summary (Last Branch)

Use Prefix Sum + HashMap

Store sum â†’ index

Same sum â†’ sum = 0

sum âˆ’ K â†’ sum = K

Time: O(n)



ğŸ“Œ Range Sum Queries (River Problem)
ğŸ”¹ Problem Description

You are given:

An array of size N (initially all 0s or given)

Q queries

Each query contains:

i â†’ starting index

j â†’ ending index (inclusive)

x â†’ value to be added

For every query:

Add x to all elements from index i to j

After processing all queries:

Find the maximum element in the array

ğŸ”¹ Why is it called River Problem?

Each query is like pouring water (x) into a range of river beds

Final water level at each index is found after all pours

We need the highest water level (max value)

ğŸ“Œ Brute Force Approach
ğŸ”¹ Idea

For every query:

Loop from i to j

Add x to each element

ğŸ”¹ Code (Brute Force)
int[] arr = new int[n];

while (q-- > 0) {
    int i, j, x;
    // read i, j, x

    for (int k = i; k <= j; k++) {
        arr[k] += x;
    }
}

// find max
int max = Integer.MIN_VALUE;
for (int val : arr) {
    max = Math.max(max, val);
}

ğŸ”¹ Time Complexity:

O(Q Ã— N) â†’ âŒ TLE for large inputs

ğŸ”¹ Space Complexity:

O(N)

ğŸ”¹ Problem with Brute Force

Too slow when:

N and Q are large

Hence we need an optimized approach

ğŸ“Œ Optimized Approach: Prefix Sum / Difference Array

ğŸ‘‰ THIS IS THE MAIN CONCEPT

ğŸ”¹ Key Idea (Difference Array)

Instead of updating the full range:

Add x at index i

Subtract x at index j + 1

Later, take prefix sum to get final values.

ğŸ”¹ Why does this work?

Prefix sum spreads the effect of x

Update cost becomes O(1) per query

ğŸ“Œ Algorithm (Step-by-Step)

Create an array diff[] of size n + 1, initialize with 0

For each query (i, j, x):

diff[i] += x

diff[j + 1] -= x

Build final array using prefix sum

Find maximum element

ğŸ“Œ Optimized Code (Java)
int[] diff = new int[n + 1];

// process queries
while (q-- > 0) {
    int i, j, x;
    // read i, j, x

    diff[i] += x;
    if (j + 1 < n)
        diff[j + 1] -= x;
}

// prefix sum + max
int max = Integer.MIN_VALUE;
int current = 0;

for (int i = 0; i < n; i++) {
    current += diff[i];
    max = Math.max(max, current);
}

System.out.println(max);

ğŸ“Œ Dry Run (Very Important for Mind Map)
Given:
n = 7
Queries:
(2, 5, 3)
(0, 1, 2)
(3, 6, -1)

Step 1: diff array
Index:  0  1  2  3  4  5  6  7
diff:   2  0  3  0  0  0 -1 -4

Step 2: Prefix Sum
Final array:
[2, 2, 5, 5, 5, 5, 4]

Step 3: Max
Max = 5

ğŸ“Œ Time & Space Complexity
ğŸ”¹ Time Complexity:

Queries â†’ O(Q)

Prefix sum â†’ O(N)

Total: O(Q + N) âœ…

ğŸ”¹ Space Complexity:

O(N)

ğŸ“Œ Comparison (Mind Map Branch)
Approach	Time
Brute Force	O(Q Ã— N) âŒ
Prefix Sum	O(Q + N) âœ…
ğŸ“Œ Final Mind Map Summary (1â€“2 Lines)

Use Difference Array + Prefix Sum

Range update in O(1)

Final array via prefix sum

Used in River / Range Sum problems



ğŸ“Œ Two Pointer Approach (DSA Concept)
ğŸ”¹ What is Two Pointer Approach?

A technique where we use two indices (pointers) to traverse a data structure.

Usually applied on sorted arrays or lists.

Helps reduce time complexity from O(nÂ²) â†’ O(n).

ğŸ”¹ Why Two Pointers?

Efficient searching

Avoid nested loops

Used in:

Two Sum

Intersection

Union

Removing duplicates

Pair problems

ğŸ”¹ Types of Two Pointers

Opposite direction

i = 0, j = n - 1

Same direction

i = 0, j = 0

ğŸ“Œ Problem 1: Two Sum Exists? (Using Two Pointers)
ğŸ”¹ Problem Statement

Given an array and a target value, check if any two elements sum up to the target.

ğŸ”¹ Key Condition

Array must be sorted

If not sorted â†’ sort first

ğŸ”¹ Algorithm

Sort the array

Initialize:

i = 0

j = n - 1

While i < j:

If arr[i] + arr[j] == target â†’ return true

If sum < target â†’ i++

If sum > target â†’ j--

Return false

ğŸ”¹ Code (Java)
public static boolean twoSum(int[] arr, int target) {
    Arrays.sort(arr);

    int i = 0, j = arr.length - 1;

    while (i < j) {
        int sum = arr[i] + arr[j];

        if (sum == target) {
            return true;
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return false;
}

ğŸ”¹ Time Complexity

Sorted array: O(n)

Unsorted array: O(n log n) + O(n)

ğŸ“Œ Problem 2: Intersection of Two Sorted Arrays
ğŸ”¹ Definition

Intersection contains common elements in both arrays
ğŸ‘‰ No duplicates allowed

ğŸ”¹ Algorithm

Use two pointers i, j

Compare a[i] and b[j]

If equal:

Add to answer (if not duplicate)

Move both pointers

If a[i] < b[j] â†’ i++

Else â†’ j++

ğŸ”¹ Code (Java)
public static List<Integer> intersection(int[] a, int[] b) {
    List<Integer> ans = new ArrayList<>();
    int i = 0, j = 0;

    while (i < a.length && j < b.length) {
        if (a[i] == b[j]) {
            if (ans.size() == 0 || ans.get(ans.size() - 1) != a[i]) {
                ans.add(a[i]);
            }
            i++;
            j++;
        } else if (a[i] < b[j]) {
            i++;
        } else {
            j++;
        }
    }
    return ans;
}

ğŸ”¹ Time Complexity
O(N + M)

ğŸ“Œ Problem 3: Union of Two Sorted Arrays
ğŸ”¹ Definition

Union contains all unique elements from both arrays.

ğŸ”¹ Algorithm

Use two pointers i, j

Add smaller element (avoid duplicates)

If both equal â†’ add once, move any pointer

Add remaining elements

ğŸ”¹ Code (Java)
public static List<Integer> union(int[] a, int[] b) {
    List<Integer> ans = new ArrayList<>();
    int i = 0, j = 0;

    while (i < a.length && j < b.length) {
        if (a[i] <= b[j]) {
            if (ans.size() == 0 || ans.get(ans.size() - 1) != a[i]) {
                ans.add(a[i]);
            }
            i++;
        } else {
            if (ans.size() == 0 || ans.get(ans.size() - 1) != b[j]) {
                ans.add(b[j]);
            }
            j++;
        }
    }

    while (i < a.length) {
        if (ans.get(ans.size() - 1) != a[i]) {
            ans.add(a[i]);
        }
        i++;
    }

    while (j < b.length) {
        if (ans.get(ans.size() - 1) != b[j]) {
            ans.add(b[j]);
        }
        j++;
    }

    return ans;
}

ğŸ”¹ Time Complexity
O(N + M)

ğŸ“Œ Final Mind Map Summary

Two Pointer = two indices

Works best on sorted arrays

Reduces time complexity

Used in:

Two Sum

Intersection

Union


ğŸ“Œ 1ï¸âƒ£ What is a Subarray?
ğŸ”¹ Definition

A subarray is a contiguous part of an array.

Elements must be continuous in index.

Example:
Array: [1, 2, 3, 4]

Subarrays:
[1], [2], [3], [4]
[1,2], [2,3], [3,4]
[1,2,3], [2,3,4]
[1,2,3,4]


âŒ [1,3] is NOT a subarray (not continuous)

ğŸ“Œ 2ï¸âƒ£ What is a Substring?
ğŸ”¹ Definition

A substring is a contiguous part of a string.

Example:
String: "abc"

Substrings:
"a", "b", "c"
"ab", "bc"
"abc"


âŒ "ac" is NOT a substring

ğŸ”¹ Difference (Exam-Important)
Concept	Used On	Continuous?
Subarray	Array	âœ… Yes
Substring	String	âœ… Yes
ğŸ“Œ 3ï¸âƒ£ What is Sliding Window Technique?
ğŸ”¹ Definition

Sliding Window is an optimization technique used to process subarrays / substrings efficiently.

Instead of recalculating from scratch, we:

Expand window â†’ add element

Shrink window â†’ remove element

ğŸ”¹ Why Sliding Window?

Avoids nested loops

Reduces time from O(nÂ²) â†’ O(n)

ğŸ”¹ Types of Sliding Window

1ï¸âƒ£ Fixed size window
2ï¸âƒ£ Variable size window

ğŸ“Œ 4ï¸âƒ£ Segment with Small Sum (sum â‰¤ K)

ğŸ‘‰ Array must contain ONLY positive numbers

ğŸ”¹ A) Longest Subarray with Sum â‰¤ K
ğŸ”¹ Idea

Expand window using e

If sum > K â†’ shrink from s

Track maximum length

ğŸ”¹ Code (Length)
int segmentWithSmallSum(int[] arr, int k) {
    int sum = 0, s = 0, len = 0;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum > k) {
            sum -= arr[s];
            s++;
        }

        len = Math.max(len, e - s + 1);
    }
    return len;
}

ğŸ”¹ Time Complexity
O(N)

ğŸ”¹ Space Complexity
O(1)

ğŸ”¹ B) Count of Subarrays with Sum â‰¤ K
ğŸ”¹ Key Observation

If window [sâ€¦e] is valid,
then all subarrays ending at e starting from s are valid.

Count added:

e - s + 1

ğŸ”¹ Code (Count)
int countSubarraysSmallSum(int[] arr, int k) {
    int sum = 0, s = 0;
    int count = 0;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum > k) {
            sum -= arr[s];
            s++;
        }

        count += (e - s + 1);
    }
    return count;
}

ğŸ“Œ 5ï¸âƒ£ Segment with Big Sum (sum â‰¥ K)

ğŸ‘‰ Array must contain ONLY positive numbers

ğŸ”¹ A) Shortest Subarray with Sum â‰¥ K
ğŸ”¹ Idea

Expand window until sum â‰¥ K

Shrink window to minimize length

ğŸ”¹ Code (Length)
int segmentWithBigSum(int[] arr, int k) {
    int sum = 0, s = 0;
    int minLen = Integer.MAX_VALUE;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum >= k) {
            minLen = Math.min(minLen, e - s + 1);
            sum -= arr[s];
            s++;
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

ğŸ”¹ Time Complexity
O(N)

ğŸ”¹ B) Count of Subarrays with Sum â‰¥ K

âš ï¸ Sliding window does NOT work directly for count
â†’ Needs Prefix Sum + Binary Search / Map

(Thatâ€™s why your sir usually separates length and count cases.)

ğŸ“Œ 6ï¸âƒ£ Sliding Window on Substring

(Longest substring with at most K distinct characters)

ğŸ”¹ Idea

Use Map<Character, Frequency>

Expand window

If distinct chars > K â†’ shrink window

ğŸ”¹ Code (Already correct in your notes)
int longestSubstringKDistinct(String str, int k) {
    Map<Character, Integer> map = new HashMap<>();
    int s = 0, len = 0;

    for (int e = 0; e < str.length(); e++) {
        char c = str.charAt(e);
        map.put(c, map.getOrDefault(c, 0) + 1);

        while (map.size() > k) {
            char cs = str.charAt(s);
            map.put(cs, map.get(cs) - 1);
            if (map.get(cs) == 0) map.remove(cs);
            s++;
        }

        len = Math.max(len, e - s + 1);
    }
    return len;
}

ğŸ“Œ Final Mind Map Summary (Very Important)

Subarray / Substring â†’ continuous

Sliding Window â†’ expand + shrink

Small Sum (â‰¤ K):

Longest length

Count = e - s + 1

Big Sum (â‰¥ K):

Shortest length

Works only for positive numbers

Important Patterns given by Sir

ğŸ“Œ Sliding Window â€“ Important Patterns (Your Page Topics)
1ï¸âƒ£ Fixed Window Size
ğŸ”¹ What is Fixed Window?

Window size is constant (K)

We slide the window one step at a time

ğŸ”¹ Used for:

Maximum / Minimum

Sum

Unique count
of each window of size K

ğŸ”¹ Example:
Array = [1, 2, 3, 4, 5]
K = 3

Windows:
[1,2,3] â†’ sum
[2,3,4] â†’ sum
[3,4,5] â†’ sum

ğŸ”¹ Fixed Window Code (Sum of each window)
int windowSum(int[] arr, int k) {
    int sum = 0;

    for (int i = 0; i < k; i++) {
        sum += arr[i];
    }

    for (int i = k; i < arr.length; i++) {
        sum += arr[i];
        sum -= arr[i - k];
    }

    return sum;
}

ğŸ”¹ Time Complexity
O(N)

2ï¸âƒ£ Sliding Window (Variable Size)
ğŸ”¹ What is Variable Window?

Window size changes dynamically

Uses two pointers:

s â†’ start

e â†’ end

ğŸ”¹ Used for:

at most K

less than or equal to K

greater than or equal to K

3ï¸âƒ£ Length of the Longest Substring with At Most K Distinct Characters
ğŸ”¹ Key Idea

â€œAt most Kâ€ â†’ sliding window

Use Map to track frequency

ğŸ”¹ Logic

Expand window (e)

Add character to map

If map size > K â†’ shrink from s

Track maximum length

ğŸ”¹ Code
int longestSubstringAtMostK(String str, int k) {
    Map<Character, Integer> map = new HashMap<>();
    int s = 0, len = 0;

    for (int e = 0; e < str.length(); e++) {
        char c = str.charAt(e);
        map.put(c, map.getOrDefault(c, 0) + 1);

        while (map.size() > k) {
            char cs = str.charAt(s);
            map.put(cs, map.get(cs) - 1);
            if (map.get(cs) == 0) map.remove(cs);
            s++;
        }

        len = Math.max(len, e - s + 1);
    }
    return len;
}

ğŸ”¹ Time Complexity
O(N)

4ï¸âƒ£ Count of Subarrays with Sum â‰¤ K

âš ï¸ Works only for positive numbers

ğŸ”¹ Key Observation (VERY IMPORTANT)

If window [sâ€¦e] has sum â‰¤ K,
then all subarrays ending at e starting from s are valid.

So we add:

count += (e - s + 1)

ğŸ”¹ Code
int countSubarraysAtMostK(int[] arr, int k) {
    int sum = 0, s = 0, count = 0;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum > k) {
            sum -= arr[s];
            s++;
        }

        count += (e - s + 1);
    }
    return count;
}

ğŸ”¹ Time Complexity
O(N)

5ï¸âƒ£ Count of Subarrays with Sum = K
ğŸ”¹ Trick You Wrote (Correct âœ…)
count(â‰¤ K) - count(â‰¤ K-1) = count(= K)

ğŸ”¹ Code
int countEqualK(int[] arr, int k) {
    return countSubarraysAtMostK(arr, k)
         - countSubarraysAtMostK(arr, k - 1);
}

ğŸ”¹ Why this works?

Sliding window easily counts â‰¤ K

Exact K is obtained by subtraction

6ï¸âƒ£ Segment with Small Sum
ğŸ”¹ Meaning

Find longest subarray with sum â‰¤ K

ğŸ”¹ Code (Length)
int longestSmallSum(int[] arr, int k) {
    int sum = 0, s = 0, len = 0;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum > k) {
            sum -= arr[s];
            s++;
        }

        len = Math.max(len, e - s + 1);
    }
    return len;
}

7ï¸âƒ£ Segment with Big Sum
ğŸ”¹ Meaning

Find shortest subarray with sum â‰¥ K

ğŸ”¹ Code (Length)
int shortestBigSum(int[] arr, int k) {
    int sum = 0, s = 0;
    int minLen = Integer.MAX_VALUE;

    for (int e = 0; e < arr.length; e++) {
        sum += arr[e];

        while (sum >= k) {
            minLen = Math.min(minLen, e - s + 1);
            sum -= arr[s];
            s++;
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

8ï¸âƒ£ Final Mind-Map Summary (EXACTLY WHAT TO REMEMBER)

Fixed window â†’ size constant

Variable window â†’ expand + shrink

At most K â†’ sliding window

Exactly K â†’
count(â‰¤K) - count(â‰¤K-1)

Small sum â†’ longest length

Big sum â†’ shortest length

Sliding window works only for positive numbers
